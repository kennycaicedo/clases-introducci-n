<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>Clases de Introducción</title>

  <!-- Bootstrap core CSS -->
  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Custom fonts for this template -->
  <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet">
  <link href="vendor/fontawesome-free/css/all.min.css" rel="stylesheet">

  <!-- Custom styles for this template -->
  <link href="css/resume.min.css" rel="stylesheet">

</head>

<body id="page-top">

  <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
    <a class="navbar-brand js-scroll-trigger" href="#page-top">
      <span class="d-block d-lg-none">Caicedo Kenny</span>
      <span class="d-none d-lg-block">
        <img class="img-fluid img-photo rounded-circle mx-auto mb-2" src="img/photo.jpg" alt="">
      </span>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav">
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#about">blog</a>
        </li>
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#experience">unidad 1</a>
        </li>
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#uno">1.1 fundamentos a la ingenieria de software</a>
        </li>
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#dos">1.2 proceso de la ingenieria de sofware</a>
        </li>
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#tres">1.3 sistemas de información</a>
        </li>
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#education">unidad 2</a>
        </li>
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#cuatro">2.1 proceso del software</a>
        </li>
        <li class="nav-item">
          <a class="nav-link js-scroll-trigger" href="#cinco">2.2 el ciclo de vida del software</a>
        </li>
        <li class="nav-item">
          <i class="nav-link js-scroll-trigger" href="#seis">2.3 modelos de desarrollo</i>
        </li>
      </ul>
    </div>
  </nav>

  <div class="container-fluid p-0">

    <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="about">
      <div class="w-100">
        <h1 class="mb-0">CLASES DE 
          <span class="text-primary">INTRODUCCIÓN A LA INGENIERÍA EN SOFTWARE</span>
        </h1>
        <div class="subheading mb-5">Correo Institucional:
          <a href="kenny.caicedob@ug.edu.ec">kenny.caicedob@ug.edu.ec</a>
        </div>
        <h1 class="mb-0">BLOG PERSONAL </h1>
        <p class="lead mb-5">En las clases de Introducción a la Ingeniería en Software he aprendido muchas conceptualizaciones sobre el Proceso del Software, su ciclo de vida y los diferentes modelos de desarrollo con los que se pueden elaborar un Producto Sofware. A continuación les dejo las clases vistas en Introducción a la Ingeniería en Software correspondientes a la UNIDAD 1 - 2</p>
        <div class="social-icons">
          <a href="https://github.com/kennycaicedo">
            <i class="fab fa-github"></i>
          </a>
          <a href="https://twitter.com/78_caicedo">
            <i class="fab fa-twitter"></i>
          </a>
          <a href="https://www.facebook.com/kenny.caicedobarzola">
            <i class="fab fa-facebook-f"></i>
          </a>
        </div>
      </div>
    </section>

    <hr class="m-0">

    <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="experience">
      <div class="w-100">
        <h2 class="mb-5">Unidad 1</h2>
        <h3 >1.1 fundamentos de la ingeniría en software</h3>
        <h3 >·  definiciones y objetivos de la ingeniería de sofware</h3>
        <h4>Definición</h4>
        <p>La ingeniería de software es una aplicación práctica del conocimiento científico para proveer metodologías y técnicas que ayuden a desarrollar sistemas de software a tiempo, y a su vez que aseguren que el desarrollador cumpla con las expectativas de calidad y permanezca dentro del presupuesto.
        <h4>Objetivos</h4> 
        <p>Diseñar programas informáticos que se adecúen a las exigencias de la sociedad.</p>  
        <p>Liderar y acoplar el desarrollo de programaciones complicadas.</p>  
        <p>Actuar en todas las fases del ciclo de vida de un producto.</p>  
        <p>Computar los costos de un proyecto y evaluar los tiempos de desarrollo.</p>  
        <p>Realizar el seguimiento de costes y plazos. </p>  
        <p>Liderar equipos de trabajo de desarrollo software.</p>  
        <p>Estructurar la elaboración de evidencias que comprueben el perfecto funcionamiento de los programas y que se adaptan a los requerimientos de análisis y diseño.</p>  
        <p>Diseñar, construir y administrar bases de datos.</p>  
        <p>Liderar y orientar a los programadores durante el desarrollo de aplicaciones.</p>  
        <p>Incluir  procesos de calidad en los sistemas, calculando métricas e indicadores y chequeando la calidad del software producido.</p>  
        
<div class="resume-content">
          <h3 >·  la evolución del software</h3>
        </p>El término “evolución” del software se utiliza desde los sesenta para denominar la dinámica de crecimiento del software.</p>
      </p>Una definición atribuida a Lehman y Ramil dice que la evolución del software es “todas las actividades de programación que se orientan a generar una nueva versión de un software a partir de una versión anterior operativa.</p>
    </p>Ned Chapin 1(1999) lo definió como “la aplicación de las actividades y procesos de mantenimiento del software que generan una nueva versión operative de un software con una funcionalidad de usuario o propiedades cambiadas a partir de una versión anterior […] junto con los procesos y actividades de garantía de calidad y con la gestión de esos procesos”. De estas definiciones se desprende que la evolución cubre el ajuste a funcionalidades adicionales.</p>
  </p>La guía SWEBOK2 considera que la causa del mantenimiento está tanto en la necesidad de “cambios” como de “evolución” en el software.</p>
</div>
<div class="resume-content">
<h3>·  la crisis del software</h3>
  <h4>¿Cómo se define crisis?</h4>
  <p>La palabra crisis se define en el diccionario como "un punto decisivo en el curso de algo; momento, etapa, o evento decisivo o crucial". Sin embargo para el software no ha habido ningún punto crucial, sólo una lenta evolución.</p>
  <p>La crisis en la industria del software permanece durante muchos años, lo cual parece una contradicción para el término. Lo que si se podría decir es que hay un problema crónico en el desarrollo de software.</p>
 <h4>¿Por qué se crea la IS?</h4>
  <p>La ingeniería de software se crea debido a las siguientes características.</p>
  <p>El producto debe ser confiable y realizar sólo las tareas especificadas en los requerimientos.</p>
  <p>El producto debe ser robusto. Esto quiere decir que el software se comporta de manera razonable, incluso en circunstancias no anticipadas desde el principio.</p>
  <p>El producto de software debe ser lo más reutilizable posible, de manera tal que pueda ser incorporado en otro producto de software si se requiere.</p>
  <p>El producto de software debe ser eficiente en el uso de los recursos del sistema.</p>
  <p>Se requiere desarrollar el software en una manera que lo haga evolutivo, de forma tal que se pueda agregar funcionalidad adicional sin efectos perjudiciales.</p>
  <p>El producto de software debe ser utilizable, es decir, el aprendizaje de su uso debe ser los suficientemente sencillo por parte de personas no especialistas.</p>
</div>
<div class="resume-content">
<h3>·  El software en la actualidad</h3>
<p>Las direcciones en las que evoluciona la ingeniería del software hoy en día pueden agruparse de la siguiente manera:</p>
<h4>Metodologías ágiles:</h4>
<p>Métodos de desarrollo de software basados en procesos iterativos e incrementales, donde los requisitos y soluciones evolucionan durante la colaboración.Metodologías como Scrum (1995), Extreme Programming (1999) o DSDM (1995) fueron evolucionando hasta que en Febrero del 2001 se publicó “Manifesto for Agile Software Development” para definir la aproximación ahora conocida como metodologías ágiles.</p>
<h4>Experimentación:</h4>
<p>Es una rama de la ingeniería del software interesada en realizar experimentos sobre software, recolectar datos y deducir leyes y teorías de los mismos.</p>
<h4>Desarrollo dirigido por modelos:</h4>
<p>Primero se desarrollan modelos textuales  gráficos del software a construir, y posteriormente se construye el software.</p>
<h4>Líneas de productos software:</h4>
<p>En lugar de productos individuales.</p>
</div>
<h3  class="mb-5"> 1.2 PROCESO de la ingeniría en software</h3>
<h3>·  Factores de calidad del software </h3>
<h4>Concepto de Calidad:</h4>
<p>Conjunto de propiedades y de características de un producto o servicio, que le confieren aptitud para satisfacer una necesidad explícita o implícita (ISO 8402).</p>
<h4>Calidad del Software: </h4>    
<p>Es el grado con el que un sistema, componente o proceso cumple los requerimientos especificados y las necesidades o expectativas del cliente o usuario.</p>
<p>Factores que determinan la calidad del software pueden clasificar en dos grandes grupos (Pressman):</p>
<h4>Medidas Directas:</h4>    
<p>La medida o medición decimos que es directa, cuando disponemos de un instrumento de medida que nos muestra un resultado (generalmente numérico).</p>
<h4>Medidas Indirectas: </h4>    
<p>Cuando hablamos de sistemas informáticos no siempre es posible realizar una medida directa, porque no disponemos del instrumento adecuado que nos permita realizar esa medición</p>
<h3>·  Problemas en el desarrollo de software</h3>
<h4>¿Qué es un proyecto software?</h4>
<p>Haciendo uso de la definición de proyecto de la guía del PMBOK, y adaptándola a un proyecto software, podríamos definirlo como: </p>
<p>“Un proyecto software es un esfuerzo temporal que se lleva a cabo para crear un producto software, servicio TI o resultado único.” </p>
<h4>¿Pero que es el software?</h4>
<p>Según la definición del IEEE, "software es la suma total de los programas de ordenador, procedimientos, reglas, la documentación asociada y los datos que pertenecen a un sistema de cómputo", y "un producto de software es un producto diseñado para un usuario". </p>
<h4>El software puede dividirse en dos grandes categorías: </h4>
<h4>Software de aplicaciones:</h4>
<p>Se usan para proveer servicios a clientes y ejecutar negocios de forma más eficiente. El software de aplicaciones puede ser un sistema pequeño o uno grande integrado. Como ejemplos de este tipo de software estarían un sistema de cuentas, un sistema de planificación de recursos.</p>
<h4>Software de sistemas:</h4>
<p>El software de sistemas se usa para operar y mantener un sistema informático. Permite a los usuarios usar los recursos del ordenador directamente y a través de otro software. Algunos ejemplos de este tipo de software son los sistemas operativos, compiladores y otras utilidades del sistema.</p>
<h3>·  la ingeniería del software</h3>
<p>Los proyectos software tienen características específicas que los hacen diferentes de otros proyectos de ingeniería.</p>
<p>La Ingeniería del Software es la rama de la ingeniería que crea y mantiene las aplicaciones de software usando tecnologías y prácticas de las ciencias de la computación, manejo de proyectos, ingeniería, el ámbito de la aplicación, y otros campos.</p>
<p>El software se desarrolla, no se fabrica en el sentido clásico de la palabra. Ambas actividades se dirigen a la construcción de un "producto", pero los métodos son diferentes. Los costes del software se encuentran en la ingeniería, esto implica que los proyectos no se pueden gestionar como si lo fueran de fabricación. </p>
<p>La juventud de la ingeniería del software con respecto a otras ingenierías, la mayoría del software se construye a medida, en vez de ensamblar componentes previamente creados. Aunque ya se están dando importantes pasos en esta dirección, que facilitaría en gran medida el desarrollo de aplicaciones informáticas. </p>
<p>En el software, el recurso principal son las personas. No es siempre posible acelerar la construcción de software añadiendo personas porque la construcción de software requiere un esfuerzo en equipo. El equipo tiene que trabajar de forma coordinada y compartir un objetivo de proyecto común. Se necesita comunicación efectiva dentro del equipo. </p>
<p>El software no se estropea, pero se deteriora. Durante su vida, el software sufre cambios (mantenimiento). Conforme se hacen los cambios, es bastante probable que se introduzcan nuevos defectos, lo que hace que el software se vaya deteriorando debido a estos cambios. </p>
<h3>·  Visión general del proceso de ingeniería del software</h3>
<h5>Con independencia del área, tamaño o complejidad del proyecto, cualquier proyecto se encontrará al menos en una de las siguientes fases:</h5>
<p>-Definición ~ Análisis (del sistema, del sw).</p>
<p>-Desarrollo ~ Diseño, codificación, prueba.</p>
<p>-Mantenimiento.</p>
<h3>·  Responsabilidad ética y profesional en ingeniería del software</h3>
<p>La IS se realiza dentro de un marco social y legal que limita la libertad de la gente que trabaja en dicha área.</p>
<h4>Los ingenieros de software: </h4>
<p>Deben aceptar que su labor implica responsabilidades mayores que la simple aplicación de habilidades técnicas.</p>
<p>Deben comportarse de forma ética y moralmente responsable para ser respetado como un ingeniero profesional.</p>
<h3 class="mb-5">1.3 Sistemas de información</h3>
<h3>·  Concepto</h3>
<p>Un sistema de información es un conjunto de elementos interrelacionados con el propósito de prestar atención a las demandas de información de una organización, para elevar el nivel de conocimientos que permitan un mejor apoyo a la toma de decisiones y desarrollo de acciones (Peña, 2006).</p>
<p>Conjunto de elementos que interactúan entre sí con el fin de apoyar las actividades de una empresa o negocio. Teniendo muy en cuenta el equipo computacional necesario para que el sistema de información pueda operar y el recurso humano que interactúa con el Sistema de Información, el cual está formado por las personas que utilizan el sistema.</p>
<p>Un sistema de información realiza cuatro actividades básicas: entrada, almacenamiento, procesamiento y salida de información (Peralta, 2008).</p>
<h3>·  información y datos</h3>
<p>Entrada de Información: Es el proceso mediante el cual el Sistema de Información toma los datos que requiere para procesar la información.
  Almacenamiento de información: El almacenamiento es una de las actividades o capacidades más importantes que tiene una computadora, ya que a través de esta propiedad el sistema puede recordar la información guardada en la sección o proceso anterior.
  Procesamiento de Información: Es la capacidad del Sistema de Información para efectuar cálculos de acuerdo con una secuencia de operaciones preestablecida. 
Salida de Información: La salida es la capacidad de un Sistema de Información para sacar la información procesada o bien datos de entrada al exterior. 
</p>
<h3>·  tipos de sistemas de información</h3>
<p>Sistemas transaccionales: Son Sistemas de Información que logran la automatización de procesos operativos dentro de una organización ya que su función primordial consiste en procesar transacciones tales como pagos, cobros, entradas, salidas, etc.</p>
<p>Sistemas de Soporte a la Toma de Decisiones, Sistemas para la Toma de Decisión de Grupo, Sistemas Expertos de Soporte a la Toma de Decisiones y Sistema de Información para Ejecutivos: Son Sistemas de Información que apoyan el proceso de toma de decisiones.</p>
<p>Sistemas Estratégicos: Son sistemas de información desarrollado en las organizaciones con el fin de lograr ventajas competitivas, a través del uso de la tecnología de información.</p>
<p>Manuales: cuando el hombre auxiliado por cierto equipo (máquinas de escribir, sumadoras, archivos, etc.) realiza las principales funciones de recopilación, registro, almacenamiento, cálculo y generación de información.</p>
<p>Mecanizadas: cuando cierta maquinaria realiza las principales funciones de procesamiento. Para los sistemas mecanizados que hacen uso de un computador, de acuerdo al tipo de interacción Hombre-Máquina, los sistemas de información pueden ser de dos tipos (Batch y en Línea]</p>
<p>Procesos centralizados: los recursos se encuentran ubicados en un área física determinada, por lo que su acceso se realiza en las misma instalación o desde lugares retirados, mediante líneas de comunicación de datos (telefónicas, microondas, satélite, etc.).</p>
<p>Proceso distribuido: los recursos se encuentran diseminados en diversos lugares de una zona territorial (ciudad, país, continente, etc.), por lo que el procesamiento se realiza en el propio lugar donde se originan los datos, existiendo la posibilidad de compartir información entre las diversas instalaciones, mediante la información de una “Red de Comunicación”.</p>

</div>
    </section>

    </section>

    <hr class="m-0">

    <section class="resume-section p-3 p-lg-5 d-flex align-items-center" id="education">
      <div class="w-100">
        <h2 class="mb-5">Unidad 2</h2>
       <h3>2.1 Proceso del software</h3>
       <h3>·  definición de proceso de software</h3>
       <p>Un conjunto estructurado de actividades necesarias para desarrollar un sistema de software.</p>
       <p>Muchos de los procesos de software son diferentes, pero todos implican:      </p>
       <p>-Especificación</p>
       <p>-Diseño e implementación      </p>
       <p>-Validación</p>
       <p>-Evolución</p>
       <h4>Cualquier proceso tiene las siguientes características:
      </h4>
       <p>El proceso establece todas las actividades principales
      </p>
       <p>El proceso utiliza recursos, está sujeto a una serie de restricciones y genera productos intermedios y finales
      </p>
       <p>El proceso puede estar compuesto de subprocesos que se encadenan de alguna manera. Puede definirse como una jerarquía de procesos organizada de modo que cada subproceso tenga su propio modelo de proceso
      </p>
       <p>Cada actividad del proceso tiene criterios de entrada y de salida, de modo que se conoce cuándo comienza y cuándo termina una actividad
      </p>
       <p>Las actividades se organizan en secuencia de modo que resulta claro cuando una actividad se realiza en orden relativo a otras actividades
      </p>
       <p>Todo proceso tiene un conjunto de principios orientadores que explican las metas de cada actividad
      </p>
       <p>Las restricciones o controles pueden aplicarse a una actividad, recurso o producto
      </p>
       


       <h3>·  Estándares relacionados con el proceso de SW </h3>
       <h4>Estándar ISO/IEC/IEEE 12207:2017      </h4>
       <p>El estándar ISO/IEC/IEEE 12207:2017 [ISO/IEC/IEEE, 2017] relativo a los procesos del ciclo de vida del software
      </p>
       <p>Se aplica a la adquisición de sistemas de software , productos y servicios, al suministro, desarrollo, operación, mantenimiento y eliminación de productos de software o componentes de software de cualquier sistema, ya sea que se realice interna o externamente a una organización.
      </p>
       <p>Se incluyen aquellos aspectos de la definición del sistema necesarios para proporcionar el contexto de los productos y servicios de software
      </p>
       <p>También proporciona procesos que pueden emplearse para definir, controlar y mejorar los procesos del ciclo de vida del software dentro de una organización o de un proyecto
      </p>
       <p>Esta norma no fomenta o especifica ningún modelo concreto de ciclo de vida, gestión del software o método de ingeniería, ni prescribe cómo realizar ninguna de las actividades
      </p>
   


<h3 class="mb-5">2.2 el ciclo de vida del software</h3>
       <h3>·  definición y etapas</h3>
       <p>Desde un punto de vista general puede considerarse que el ciclo de vida de un software tiene tres etapas claramente diferenciadas:
      </p>
<h4>Planificación: </h4>
<p>Idearemos un planeamiento detallado que guíe la gestión del proyecto, temporal y económicamente.
</p>
<h4>Implementación: </h4>
<p>Acordaremos el conjunto de actividades que componen la realización del producto.</p>
<h4>Puesta en producción: </h4>
<p>Nuestro proyecto entra en la etapa de definición, allí donde se lo presentamos al cliente o usuario final, sabiendo que funciona correctamente y responde a los requerimientos solicitados en su momento. Esta etapa es muy importante no sólo por representar la aceptación o no del proyecto por parte del cliente o usuario final sino por las múltiples dificultades que suele presentar en la práctica, alargándose excesivamente y provocando costos no previstos.
</p>
<h3>·  Ámbito general del ciclo de vida del SW </h3>
<h4>Especificaciones: </h4>
<p>Formalizamos los requerimientos; el documento obtenido en la etapa anterior se tomará como punto de partida para esta etapa.
</p>
<h4>Análisis: </h4>
<p>Determinamos los elementos que intervienen en el sistema a desarrollar, su estructura, relaciones, evolución temporal, funcionalidades, tendremos una descripción clara de qué producto vamos a construir, qué funcionalidades aportará y qué comportamiento tendrá.
</p>
<h4>Diseño: </h4>
<p>Ya sabemos qué hacer, ahora tenemos que determinar cómo debemos hacerlo (¿cómo debe ser construido el sistema en cuestion?; definimos en detalle entidades y relaciones de las bases de datos, seleccionamos el lenguaje que vamos a utilizar, el Sistema Gestor de Bases de Datos, etc.).</p>
<h4>Implementación: </h4>
<p>Empezamos a codificar algoritmos y estructuras de datos, de- finidos en las etapas anteriores, en el correspondiente lenguaje de programación o para un determinado sistema gestor de bases de datos. En muchos proyectos se pasa directamente a esta etapa; son proyectos muy arriesgados que adoptan un modelo de ciclo de vida de code & fix (codificar y corregir) donde se eliminan las etapas de especificaciones, análisis y diseño con la consiguiente pérdida de control sobre la gestión del proyecto.
</p>
<h4>Debugging: </h4>
<p>El objetivo de esta etapa es garantizar que nuestro programa no contiene errores de diseño o codificación. En esta etapa no deseamos saber si nuestro programa realiza lo que solicitó el usuario, esa tarea le corresponde a la etapa de implementación. En ésta deseamos encontrar la mayor cantidad de errores. Todas los programas contienen errores: encontrarlos es cuestión de tiempo. Lo ideal es encontrar la mayoría, si no todos, en esta etapa. También se pueden agregar testeos de performance.
</p>
<h4>Validación: </h4>
<p>Esta etapa tiene como objetivo la verificación de que el sistema desarrollado cumple con los requerimientos expresados inicialmente por el cliente y que han dado lugar al presente proyecto. En muchos proyectos las etapas de validación y debugging se realizan en paralelo por la estrecha relación que llevan. Sin embargo, tenemos que evitar la confusión: podemos realizarlos en paralelo, pero no como una única etapa.
</p>
<h4>Evolución: </h4>
<p>En la mayoría de los proyectos se considera esta etapa como Mantenimiento y evolución, y se le asigna, no sólo el agregado de nuevas funcionalidades (evolución); sino la corrección de errores que surgen (mantenimiento). En la práctica esta denominación no es del todo errónea, ya que es posible que aun luego de una etapa de debugging y validación exhaustiva, se filtren errores.
</p>
<h4></h4>
<p></p>
<h3 class="mb-5">2.3  Modelos de desarrollo: tradicionales vs alternativos</h3>
<h3>·  Modelo de proceso de SW  </h3>    
<p>Hay varios modelos de procesos definidos en la bibliografía de Ingeniería del Software
</p>
<p>Cada modelo de proceso representa un proceso desde una perspectiva particular, por lo que sólo ofrece una información parcial sobre dicho proceso.
</p>
<h3>·  Modelos tradicionales </h3>   
<h4>Modelo de Cascada
</h4>
<h6>Las fases están identificadas por separado: 
</h6> 
<p>-El análisis  y definición de requerimientos</p>
<p>-Diseño del sistema y software.
</p>
<p>-Pruebas de implementación de unidades
</p>
<p>-Integración y pruebas del sistema 
</p>
<p>-Operación y mantenimiento 
</p>
<p>El principal inconveniente del modelo de la cascada es la dificultad de acomodar el cambio después de que está en marcha el proceso. En principio, una fase tiene que ser completada antes de pasar a la siguiente fase.
</p>

<h4>Desarrollo incremental
</h4>
<h6>Beneficios: 
</h6>
<p>El costo de atender las necesidades cambiantes de los clientes se reduce.</p>
<p>-La cantidad de análisis y la documentación que tiene que ser hecho de nuevo es mucho menor que la que se requiere con el modelo de cascada. 
</p>
<p>Es más fácil obtener retroalimentación de los clientes en el trabajo de desarrollo que se ha hecho.
</p>
<p>-Los clientes pueden hacer comentarios sobre las manifestaciones del software y ver cuánto se ha implementado. 
</p>
<p>Más rápida entrega y despliegue de software de utilidad para el cliente es posible. 
</p>
<p>-Los clientes pueden usar y obtener valor a partir del software anterior que es posible con un proceso de cascada.
</p>
<h4>Espiral</h4>
<img src="img/Imagen1.png" alt="">
<p>Es un modelo de ciclo de vida desarrollado por Barry Boehm en 1988. 
</p>
<p>Las actividades de este modelo son una espiral, cada bucle es una actividad. 
</p>
<p>Las actividades no están fijadas a prioridad, sino que las siguientes se eligen en función del análisis de riesgo, comenzando por el bucle interior.
</p>
<p>En este modelo, el esfuerzo de desarrollo es iterativo. Tan pronto como uno completa un esfuerzo de desarrollo, otro comienza. Además, en cada desarrollo ejecutado, puedes seguir estos cuatros pasos.
</p>
<p>1. Determinar qué quieres lograr. 
</p>
<p>2. Determinar las rutas alternativas que puedes tomar para lograr estas metas. Por cada una, analizar los riesgos y resultados finales, y seleccionar la mejor. 
</p>
<p>3. Seguir la alternativa seleccionada en el paso 2. 	
</p>
<p>4. Establecer qué tienes terminado. 
</p>
<p>El Modelo Espiral mejora el Modelo de Cascada enfatizando la naturaleza iterativa del proceso de diseño. Eso introduce un ciclo de prototipo iterativo. En cada iteración, las nuevas expresiones que son obtenidas transformando otras dadas son examinadas para ver si representan progresos hacia el objetivo.  
</p>
<h3>·  Modelos ágiles </h3>   
<h4>definición</h4>
<p>Un proceso de software ágil debe adaptarse incrementalmente. Para lograr la adaptación incremental, un equipo ágil requiere retroalimentación con el cliente (de modo que sea posible hacer las adaptaciones apropiadas).
  Un catalizador eficaz para la retroalimentación con el cliente es un prototipo operativo o una porción de un sistema operativo. – Qué estrategia se debe aplicar?
  Este enfoque iterativo permite que el cliente evalúe en forma regular el incremento de software, dé la retroalimentación necesaria al equipo de software e influya en las adaptaciones del proceso que se realicen para aprovechar la retroalimentación.</p>
</div>
    </section>
</div>

  <!-- Bootstrap core JavaScript -->
  <script src="vendor/jquery/jquery.min.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

  <!-- Plugin JavaScript -->
  <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

  <!-- Custom scripts for this template -->
  <script src="js/resume.min.js"></script>

</body>

</html>
